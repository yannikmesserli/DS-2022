<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

    <style>
      html,
      body,
      #viewDiv {
        padding: 0;
        margin: 0;
        height: 100%;
        width: 100%;
      }

      #menu {
        padding: 0.8em;
        max-width: 250px;
      }

      #sliceContainer {
        width: inherit;
      }

      #sliceOptions {
        margin: 0 15px;
      }

      #sliceOptions > button {
        margin-bottom: 15px;
      }

      #sliceContainer {
        max-width: 228px;
      }
    </style>

    <link
      href="https://jsdev.arcgis.com/4.22/esri/themes/light/main.css"
      rel="stylesheet"
      type="text/css"
    />
    <script src="https://jsdev.arcgis.com/4.22/"></script>

    <script>
      require([
        "esri/Map",
        "esri/views/SceneView",
        "esri/layers/FeatureLayer",
        "esri/renderers/SimpleRenderer",
        "esri/symbols/PolygonSymbol3D",
        "esri/symbols/ExtrudeSymbol3DLayer",
        "esri/widgets/Expand",
        "esri/widgets/Legend",
        "esri/widgets/LayerList",
        "esri/widgets/Fullscreen",
      ], (
        Map,
        SceneView,
        FeatureLayer,
        SimpleRenderer,
        PolygonSymbol3D,
        ExtrudeSymbol3DLayer,
        Expand,
        Legend,
        LayerList,
        Fullscreen
      ) => {
        // The building footprints used in this example don't have information about the building height.
        // We are using Arcade expressions to extrude footprints dependant on their area:
        var expresion = `
              var area = Area($feature, 'square-meters'); //square-feet
              var randomness = (8 * Random() -4);
              var height;
              if (area < 500) {
                height = 5;
              } else if (area < 1000) {
                height = 6;
              } else if (area < 2000) {
                height = 16;
              } else {
                height = 12;
              }
              return height + randomness;
            `;

        function getBuildingSymbol(color) {
          return {
            type: "polygon-3d", // autocasts as new PolygonSymbol3D()
            symbolLayers: [
              {
                type: "extrude", // autocasts as new ExtrudeSymbol3DLayer()
                material: { color: color },
              },
            ],
          };
        }
        const buildingsRenderer = {
          type: "unique-value", // autocasts as new UniqueValueRenderer()
          defaultSymbol: getBuildingSymbol("#fff8eb"),
          defaultLabel: "Building General",
          field: "FEATURECODE",
          uniqueValueInfos: [
            {
              //const colors = ["#524834", "#715b38", "#8f6e3c", "#ae8140", "#cc9444", "#eba748", "#eeb664", "#f0c47f", "#f9e0b7", "#fff8eb"];
              value: "Education Facility",
              symbol: getBuildingSymbol("#f9e0b7"), //"#A7C636"),
              label: "Education Facility",
            },
            {
              value: "Industrial Facility",
              symbol: getBuildingSymbol("#f0c47f"), //"#FC921F"),
              label: "Industrial Facility",
            },
            {
              value: "Commercial or Retail Facility",
              symbol: getBuildingSymbol("#eeb664"), //"#ED5151"),
              label: "Commercial or Retail Facility",
            },
            {
              value: "Government or Military Facility",
              symbol: getBuildingSymbol("#eba748"), //"#149ECE"),
              label: "Government or Military Facility",
            },
          ],
          visualVariables: [
            {
              type: "size",
              // In case your dataset doesn't have a building height saved in an attribute,
              //you can use a value expression to extrude the footprint by a guessed value based on geometry area.
              //field: "HEIGHT",
              valueExpression: expresion,
            },
          ],
        };

        const buildings = new FeatureLayer({
          url: "https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/Building_Footprints/FeatureServer",
          title: "Buildings",
          renderer: buildingsRenderer,
        });

        const collectorRenderer = {
          type: "simple", // autocasts as new SimpleRenderer()
          symbol: {
            type: "line-3d",
            symbolLayers: [
              {
                type: "path",
                profile: "quad",
                join: "bevel",
                material: {
                  color: "#3bc7e5", //34c7b4", //51b9b8", //[0, 115, 76],
                },
                width: 3,
                height: 3,
              },
            ],
          },
          visualVariables: [
            {
              type: "size",
              //field: "DiameterEsri"
              valueExpression: `$feature.DiameterEsri*0.0254`, //*39.3701
            },
          ],
        };

        const tubesRenderer = {
          type: "simple", // autocasts as new SimpleRenderer()
          symbol: {
            type: "line-3d",
            symbolLayers: [
              {
                type: "path",
                profile: "circle",
                join: "bevel",
                material: {
                  color: "#3bc7e5", //"#51b9b8", //[0, 115, 76],
                },
                width: 1,
                height: 1,
              },
            ],
          },
          visualVariables: [
            {
              type: "size",
              //field: "DiameterEsri"
              valueExpression: `$feature.DiameterEsri*0.0254`, //*39.3701
            },
          ],
        };
        const collector = new FeatureLayer({
          url: "https://services2.arcgis.com/cFEFS0EWrhfDeVw9/arcgis/rest/services/Redlands_Storm_Drains/FeatureServer",
          title: "Storm Collector",
          definitionExpression: "ProfileType IN ('Box','') OR ProfileType IS NULL",
          elevationInfo: {
            mode: "relative-to-ground",
            offset: -4,
          },
          renderer: collectorRenderer,
        });

        const tubes = new FeatureLayer({
          url: "https://services2.arcgis.com/cFEFS0EWrhfDeVw9/arcgis/rest/services/Redlands_Storm_Drains/FeatureServer",
          title: "Storm Drains",
          definitionExpression: "ProfileType IN ('Tube','') OR ProfileType IS NULL",
          elevationInfo: {
            mode: "relative-to-ground",
            offset: -4,
          },
          renderer: tubesRenderer,
        });

        const view = new SceneView({
          container: "viewDiv",

          map: new Map({
            basemap: "dark-gray-vector",
            ground: "world-elevation",
            layers: [buildings, collector, tubes],
          }),
          camera: {
            position: {
              spatialReference: {
                latestWkid: 3857,
                wkid: 102100,
              },
              x: -13043899.261905594,
              y: 4036351.3913067374,
              z: 501.0557425133884,
            },
            heading: 291.23421061365093,
            tilt: 82.04610533060757,
          },
          qualityProfile: "high",
        });

        view.when(() => {
          // allow navigation above and below the ground
          view.map.ground.navigationConstraint = {
            type: "none",
          };
          //view.map.ground.surfaceColor = "#fff";
          // to see through the ground, set the ground opacity to 0.4
          view.map.ground.opacity = 0.6;
        });

        const layerExpand = new Expand({
          view: view,
          content: new LayerList({
            view: view,
          }),
          group: "top-right",
          expanded: false,
        });
        view.ui.add(layerExpand, "top-right");

        const legendExpand = new Expand({
          view: view,
          content: new Legend({
            view: view,
          }),
          group: "top-right",
          expanded: false,
        });
        view.ui.add(legendExpand, "top-right");

        view.popup.defaultPopupTemplateEnabled = true;

        const fullscreen = new Fullscreen({
          view: view,
        });
        view.ui.add(fullscreen, "bottom-left");
      });
    </script>
  </head>

  <body>
    <div id="viewDiv"></div>
  </body>
</html>
